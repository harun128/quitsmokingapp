{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = require(\"react\");\n\nvar _defaultMessages = _interopRequireDefault(require(\"./defaultMessages\"));\n\nvar _defaultRules = _interopRequireDefault(require(\"./defaultRules\"));\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar ValidationComponent = function (_Component) {\n  (0, _inherits2.default)(ValidationComponent, _Component);\n\n  var _super = _createSuper(ValidationComponent);\n\n  function ValidationComponent(props) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, ValidationComponent);\n    _this = _super.call(this, props);\n    _this.errors = [];\n    _this.deviceLocale = props.deviceLocale || 'en';\n    _this.rules = props.rules || _defaultRules.default;\n    _this.messages = props.messages || _defaultMessages.default;\n    _this.state = {\n      error: false\n    };\n    return _this;\n  }\n\n  (0, _createClass2.default)(ValidationComponent, [{\n    key: \"validate\",\n    value: function validate(fields) {\n      this._resetErrors();\n\n      for (var _i = 0, _Object$keys = Object.keys(this.state); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        var rules = fields[key];\n\n        if (rules) {\n          this._checkRules(key, rules, this.state[key]);\n        }\n      }\n\n      ;\n      return this.isFormValid();\n    }\n  }, {\n    key: \"_checkRules\",\n    value: function _checkRules(fieldName, rules, value) {\n      if (!value && !rules.required) {\n        return;\n      }\n\n      for (var _i2 = 0, _Object$keys2 = Object.keys(rules); _i2 < _Object$keys2.length; _i2++) {\n        var key = _Object$keys2[_i2];\n        var isRuleFn = typeof this.rules[key] == \"function\";\n        var isRegExp = this.rules[key] instanceof RegExp;\n\n        if (isRuleFn && !this.rules[key](rules[key], value) || isRegExp && !this.rules[key].test(value)) {\n          this._addError(fieldName, key, rules[key], isRuleFn);\n        }\n      }\n    }\n  }, {\n    key: \"_addError\",\n    value: function _addError(fieldName, rule, value, isFn) {\n      value = rule == 'minlength' ? value - 1 : value;\n      var errMsg = this.messages[this.deviceLocale][rule].replace(\"{0}\", fieldName).replace(\"{1}\", value);\n\n      var _this$errors$filter = this.errors.filter(function (err) {\n        return err.fieldName === fieldName;\n      }),\n          _this$errors$filter2 = (0, _slicedToArray2.default)(_this$errors$filter, 1),\n          error = _this$errors$filter2[0];\n\n      if (error) {\n        var index = this.errors.indexOf(error);\n        error.messages.push(errMsg);\n        error.failedRules.push(rule);\n        this.errors[index] = error;\n      } else {\n        this.errors.push({\n          fieldName: fieldName,\n          failedRules: [rule],\n          messages: [errMsg]\n        });\n      }\n\n      this.setState({\n        error: true\n      });\n    }\n  }, {\n    key: \"_resetErrors\",\n    value: function _resetErrors() {\n      this.errors = [];\n    }\n  }, {\n    key: \"isFieldInError\",\n    value: function isFieldInError(fieldName) {\n      return this.errors.filter(function (err) {\n        return err.fieldName === fieldName;\n      }).length > 0;\n    }\n  }, {\n    key: \"isFormValid\",\n    value: function isFormValid() {\n      return this.errors.length == 0;\n    }\n  }, {\n    key: \"getFailedRules\",\n    value: function getFailedRules() {\n      var failedRulesPerField = {};\n\n      for (var index = 0; index < this.errors.length; index++) {\n        var error = this.errors[index];\n        failedRulesPerField[error.fieldName] = error.failedRules;\n      }\n\n      return failedRulesPerField;\n    }\n  }, {\n    key: \"getFailedRulesInField\",\n    value: function getFailedRulesInField(fieldName) {\n      var foundError = this.errors.find(function (err) {\n        return err.fieldName === fieldName;\n      });\n\n      if (!foundError) {\n        return [];\n      }\n\n      return foundError.failedRules;\n    }\n  }, {\n    key: \"getErrorMessages\",\n    value: function getErrorMessages() {\n      var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\\n\";\n      return this.errors.map(function (err) {\n        return err.messages.join(separator);\n      }).join(separator);\n    }\n  }, {\n    key: \"getErrorsInField\",\n    value: function getErrorsInField(fieldName) {\n      var foundError = this.errors.find(function (err) {\n        return err.fieldName === fieldName;\n      });\n\n      if (!foundError) {\n        return [];\n      }\n\n      return foundError.messages;\n    }\n  }]);\n  return ValidationComponent;\n}(_react.Component);\n\nexports.default = ValidationComponent;\nValidationComponent.propTypes = {\n  deviceLocale: _propTypes.default.string,\n  rules: _propTypes.default.object,\n  messages: _propTypes.default.object\n};","map":{"version":3,"sources":["C:/Projeler/quitsmoking/node_modules/react-native-form-validator/index.js"],"names":["ValidationComponent","props","errors","deviceLocale","rules","defaultRules","messages","defaultMessages","state","error","fields","_resetErrors","Object","keys","key","_checkRules","isFormValid","fieldName","value","required","isRuleFn","isRegExp","RegExp","test","_addError","rule","isFn","errMsg","replace","filter","err","index","indexOf","push","failedRules","setState","length","failedRulesPerField","foundError","find","separator","map","join","Component","propTypes","PropTypes","string","object"],"mappings":"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","sourcesContent":["'use strict';\n\nimport PropTypes from 'prop-types';\nimport { Component } from 'react';\nimport defaultMessages from './defaultMessages';\nimport defaultRules from './defaultRules';\n\nexport default class ValidationComponent extends Component {\n\n  constructor(props) {\n      super(props);\n      // array to store error on each fields\n      // ex:\n      // [{ fieldName: \"name\", messages: [\"The field name is required.\"] }]\n      this.errors = [];\n      // Retrieve props\n      this.deviceLocale = props.deviceLocale || 'en'; // ex: en, fr\n      this.rules = props.rules || defaultRules; // rules for Validation\n      this.messages = props.messages || defaultMessages;\n      this.state = { error: false };\n  }\n\n  /*\n  * Method validate to verify if each children respect the validator rules\n  * Fields example (Array) :\n  * fields = {\n  *  input1: {\n  *    required:true,\n  *     numbers:true,\n  *     maxLength:5\n  *  }\n  *}\n  */\n  validate(fields) {\n    // Reset errors\n    this._resetErrors();\n    // Iterate over inner state\n    for (const key of Object.keys(this.state)) {\n      // Check if child name is equals to fields array set up in parameters\n      const rules = fields[key];\n      if (rules) {\n        // Check rule for current field\n        this._checkRules(key, rules, this.state[key]);\n      }\n    };\n    return this.isFormValid();\n  }\n\n  // Method to check rules on a spefific field\n  _checkRules(fieldName, rules, value) {\n    if (!value && !rules.required ) {\n      return; // if value is empty AND its not required by the rules, no need to check any other rules\n    }\n    for (const key of Object.keys(rules)) {\n      const isRuleFn = (typeof this.rules[key] == \"function\");\n      const isRegExp = (this.rules[key] instanceof RegExp);\n      if ((isRuleFn && !this.rules[key](rules[key], value)) || (isRegExp && !this.rules[key].test(value))) {\n        this._addError(fieldName, key, rules[key], isRuleFn);\n      }\n    }\n  }\n\n  // Add error\n  // ex:\n  // [{ fieldName: \"name\", messages: [\"The field name is required.\"] }]\n  _addError(fieldName, rule, value, isFn) {\n    value = rule == 'minlength'? value-1 : value;\n    const errMsg = this.messages[this.deviceLocale][rule].replace(\"{0}\", fieldName).replace(\"{1}\", value);\n    let [error] = this.errors.filter(err => err.fieldName === fieldName);\n    // error already exists\n    if (error) {\n      // Update existing element\n      const index = this.errors.indexOf(error);\n      error.messages.push(errMsg);\n      error.failedRules.push(rule);\n      this.errors[index] = error;\n    } else {\n      // Add new item\n      this.errors.push({\n        fieldName,\n        failedRules: [rule],\n        messages: [errMsg]\n      });\n    }\n    this.setState({ error: true });\n  }\n\n  // Reset error fields\n  _resetErrors() {\n    this.errors = [];\n  }\n\n  // Method to check if the field is in error\n  isFieldInError(fieldName) {\n    return (this.errors.filter(err => err.fieldName === fieldName).length > 0);\n  }\n\n  isFormValid() {\n    return this.errors.length == 0;\n  }\n\n  // Return an object where the keys are the field names and the value is an array with the rules that failed validation\n  getFailedRules() {\n    let failedRulesPerField = {}\n    for (let index = 0; index < this.errors.length; index++) {\n      let error = this.errors[index];\n      failedRulesPerField[error.fieldName] = error.failedRules\n    }\n    return failedRulesPerField\n  }\n\n  // Return the rules that failed validation for the given field\n  getFailedRulesInField(fieldName) {\n    const foundError = this.errors.find(err => err.fieldName === fieldName)\n    if (!foundError) {\n      return []\n    }\n    return foundError.failedRules\n  }\n\n  // Concatenate each error messages\n  getErrorMessages(separator=\"\\n\") {\n    return this.errors.map((err) => err.messages.join(separator)).join(separator);\n  }\n\n  // Method to return errors on a specific field\n  getErrorsInField(fieldName) {\n    const foundError = this.errors.find(err => err.fieldName === fieldName)\n    if (!foundError) {\n      return []\n    }\n    return foundError.messages\n  }\n}\n\n// PropTypes for component\nValidationComponent.propTypes = {\n  deviceLocale: PropTypes.string, // Used for language locale\n  rules: PropTypes.object, // rules for validations\n  messages : PropTypes.object // messages for validation errors\n}\n"]},"metadata":{},"sourceType":"script"}